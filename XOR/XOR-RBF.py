# -*- coding: utf-8 -*-
"""XORRBF.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10tKW0cQwQd3hxyVPaU4OA8GhLgPJmOIq
"""

import numpy as np
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import keras
import numpy as np
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.optimizers import Adam
x = np.array([[0,0],[0,1],[1,0],[1,1]])
y = np.array([[0],[1],[1],[0]])
obb=KMeans(4)
obb.fit(x)
km = obb.cluster_centers_
b=np.ones(4)
class RBF:
  
  def __init__(self,input,target,neurons=4,centers=km,bias=b):
    self.input=input
    self.target=target
    self.neurons=neurons
    self.bias=bias
    self.centers=centers
  
  def distance(self,a,b):
    if(np.ndim(a)==0 and np.ndim(b)==0):
      return np.abs(a-b)
    else:
      sum=0
      for i in range(len(a)):
        sum += pow(a[i]-b[i],2)
      return np.sqrt(sum)
    
  def predict(self,input):
    x2=[]
    for i in range(self.input.shape[0]):
      a1=np.zeros(self.neurons)
      for j in range(self.neurons):
        a1[j]=np.exp(-((self.distance(self.input[i],self.centers[j])*self.bias[j])**2))
      x2.append(a1)  
      print(np.array(x2))
      print(self.centers)    
    model=Sequential()
    model.add(Dense(1,activation='linear'))
    model.compile(loss='mse',optimizer='adam')
    model.fit(np.array(x2),self.target,epochs=2000)
    return model.predict(np.array(x2))           
#m=rbf(x,y)
#m=RBF(x,y,2,np.array([[0,1],[1,0]]),np.array([1,1,1]))
print(m.predict(x))